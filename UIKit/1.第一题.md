## 1.`UIView` 和 `CALayer` 是什么关系？


`UIView` 和 `CALayer` 算是相互补充的关系。

`UIView` = `CALayer.delegate` 

`UIView` : 负责用户的交互事件。

`CALayer`: 负责图像和动画的渲染。

自己查阅资料的详解：
UIView<br>
（1）【元素基础】 iOS系统中界面元素的基础, 所有的界面元素都继承自它, <br>	
（2）【mvc模式】本身完全是由CoreAnimation来实现. 真正的绘图部分, 是由一个CALayer类来管理[model] ，使用了mvc的模式，c[UIView ] m[CALayer] , v[绘制的单元 ，cpu，gpu，屏幕].<br>
（3）【管理器】UIView更像是一个CALayer的管理器, 
	所以访问它的与绘图和坐标相关的属性, 如frame, bounds等, 实际上都是在访问其所包含的CALayer的相关属性. 
	因此, 可以在所有UIView的子类上实现动画效果. UIView继承自UIResponder, 能接收并响应事件, 负责显示内容的管理, 而CALayer继承自NSObject, 不能响应事件, 负责显示内容的绘制.

UIview 上的Layer属性： self.view.layer 获取layer属性；

```
+ (Class)layerClass {
     return [CAEAGLLayer class];
}
```
这个方法返回使用的layer的类；使UIview继承的类使用指定的layer来进行绘制，如上面代码可以使用openGL来进行绘制；

CALayer的层级关系和UIView 有点类似； 
```
CAEAGLLayer *eaglLayer = [CAEAGLLayer layer];
eaglLayer.frame = self.view.frame;
eaglLayer.opaque = YES;
eaglLayer.drawableProperties = [NSDictionary dictionaryWithObjectsAndKeys:[NSNumber numberWithBool:YES],kEAGLDrawablePropertyRetainedBacking,kEAGLColorFormatRGBA8,kEAGLDrawablePropertyColorFormat, nil];
[self.view.layer addSublayer:eaglLayer];
```

因为CALayer是用来展示的，CALayer更新的时候不能够立即显示，可以使用setNeedsDisplay 方法来进行绘制显示；

CALayer
一个UIView 可以有多个CALayer，UIView的尺寸样式都是由内部的CALayer来提供的；
每一个CALayer显示一种效果, 因此, 通过添加多种效果的CALayer, 以增强UIView的显示能力. 
如UIView自身不能设置圆角等效果, 而CALayer可设置边框, 圆角, 阴影和变换变形等. 两者都有树状层级结构, CALayer有subLayers, UIView有subViews.

contents属性
CALayer *aLayer = [[CALayer alloc] init;
aLayer.contents = [[UIImage imageNamed:@"testImage"] CGImage];
aLayer.contentsGravity = kCAGravityResizeAspectFill;
这里使用图片给contents赋值的话, 一定要是CGImage. 
可以通过设置contentsGravity设置其显示模式, 相当于UIView的contentMode, 如kCAGravityResizeAspectFill 是铺满的 。kCAGravityResizeAspect 是显示自己本身的大小 。 
若果图片超出CALayer 可以使用maskToBounds 进行裁剪 ，剪掉超出的部分 （配合圆角使用不错）。
尤其是Layer的圆角等等，图片上会有性能问题这个怎么进行处理？？？<br>
????

contentsRect
用来裁剪图片, 默认的contentsRect是{0, 0, 1, 1}, 即整个图都默认可见. 如果我们改成{0,0,0.5,0.5} 图像就就会被裁剪掉左上角的1/4.

CALayer效果
aLayer.backgroundColor = [[[UIColor redColor] colorWithAlphaComponent:0.2] CGColor];
// 边框
aLayer.boardColor = [[UIColor blueColor] CGColor];
aLayer.boardWidth = 2.0;
// 圆角
aLayer.cornerRadius = 10.0;
// 阴影
aLayer.shadowColor = [[UIColor greenColor] CGColor];
aLayer.shadowOpacity = 0.5;
aLayer.shadowOffset = CGSizeMake(2, 1);
[self.view.layer addSublayer:aLayer];

变换
QuartzCore的CATransform3D提供了旋转,缩放和倾斜等变换效果. 
添加3D或者仿射变换如下:

myView.layer.transform = CATransform3DMakeScale(-1.0, -1.0, 1.0);
CGAffineTransform transform = CGAffineTransformMakeRotation(45.0);
myView.layer.affineTransform = transform;
取消动画可以使用[layer removeAllAnimations]; 
可参考swift详解之二十四—————CoreAnimation(一)CALayer.

UIView与CALayer的区别 <br>
(1)UIView继承自UIResponder，主要特点是可以响应触摸事件。
(2)CALayer是实际的图层内容管理, 不会直接渲染到屏幕上;

UIApplication, UIViewController, UIView和所有从UIView派生出来的UIKit类(包括UIWindow)都直接或间接地继承自UIResponder类.UIResponder中定义了处理各种事件和事件传递的接口.处理事件如touchesBegan:withEvent:, touchesMoved:withEvent:, touchesEnded:withEvent:等. 
而CALayer直接继承自NSObject, 并没有相应的处理事件的接口. 


https://blog.csdn.net/chun799/article/details/8223612
https://yishuiliunian.gitbooks.io/implementate-tableview-to-understand-ios/content/uikit/1-1-2.html

frame, position, bounds调用
一个CALayer的frame是由其anchorPoint, position, bounds, transform共同决定的, 而一个UIView的的frame只是简单地返回CALayer的frame, 同样UIView的center和bounds也只是简单返回CALayer的Position和Bounds对应属性.


<h1>机制与策略分离</h1>
UIView主要是对显示内容的管理, 而CALayer主要是显示内容的绘制. UIView是CALayer的CALayerDelegate, 在代理方法内部[UIView(CALayerDelegate) drawLayer:inContext]调用UIView的drawRect方法, 从而绘制出UIView的内容. UIView的显示内容由内部的CALayer:display方法来实现. 
编程问题都可以抽离出机制和策略部分。机制一旦实现，就会很少更改，但策略会经常得到优化。CALayer也可以看做是一种机制，提供图层绘制，CALayer的头文件基本上是没怎么变过的，而UIView可以看做是策略，变动很多。越是底层越是机制，越是机制就越是稳定。机制与策略分离，可以使得需要修改的代码更少，特别是底层代码，这样可以提高系统的稳定性。UIView遮蔽了大部分的CALayer接口，抽取构造出更易用的frame和动画实现，这样上手更容易。


CALayer默认产生隐式动画
CALayer默认修改属性支持隐式动画. 对于每一个 UIView 都有一个 layer,把这个 layer 且称作RootLayer,而不是 View 的根 Layer的叫做 非 RootLayer。我们对UIView的属性修改时时不会产生默认动画，而对单独 layer属性直接修改会，这个默认动画的时间缺省值是0.25s. 即在做 iOS 动画的时候，修改非 RootLayer的属性（譬如位置、背景色等）会默认产生隐式动画，而修改UIView则不会。 
在给UIView的CALayer做动画的时候, UIView作为CALayer的代理, CALayer通过actionForLayer:forKey:向UIView请求相应的动画action. 
在 Core Animation 编程指南的 “How to Animate Layer-Backed Views” 中，对为什么会这样做出了一个解释：

UIView 默认情况下禁止了 layer 动画，但是在 animation block 中又重新启用了它们 
是因为任何可动画的 layer 属性改变时，layer 都会寻找并运行合适的 ‘action’ 来实行这个改变。在 Core Animation 的专业术语中就把这样的动画统称为动作 (action，或者 CAAction)。 
layer 通过向它的 delegate 发送 actionForLayer:forKey: 消息来询问提供一个对应属性变化的 action。delegate 可以通过返回以下三者之一来进行响应： 
它可以返回一个动作对象，这种情况下 layer 将使用这个动作。 
它可以返回一个 nil， 这样 layer 就会到其他地方继续寻找。 
它可以返回一个 NSNull 对象，告诉 layer 这里不需要执行一个动作，搜索也会就此停止。 
当 layer 在背后支持一个 view 的时候，view 就是它的 delegate； 
这部分的具体内容参考：http://objccn.io/issue-12-4/重点内容
https://objccn.io/issue-12-4/

<h1>IOS面试题总结--UIView和CALayer的层级关系和区别</h1>
1.由于UIView继承自UIResponse,所以它是可以相应时间的，而CALayer是继承自NSObject，没有可以相应时间的接口。

2.UIView侧重于展示内容，而CALayer则侧重于图形和界面的绘制。

3.当View展示的时候，View是layer的CALayerDelegate,View展示的内容是由CALayer进行display的。

4.View内容的展示依赖于CALayer对于内容的绘制，UIView的frame也是由内部的CALayer进行绘制的。

5.对于UIView的属性修改，不会引起动画效果，但是对于CALayer的属性修改，是支持默认动画效果的，在VIew执行动画的时候，VIew是layer的代理，layer通过actionForLayer：forkey相对应的代理VIew请求动画action。[实现了对应的代理效果]

1.首先UIView可以响应事件，Layer不可以.

UIKit使用UIResponder作为响应对象，来响应系统传递过来的事件并进行处理。UIApplication、UIViewController、UIView、和所有从UIView派生出来的UIKit类（包括UIWindow）都直接或间接地继承自UIResponder类。

在 UIResponder中定义了处理各种事件和事件传递的接口, 而 CALayer直接继承 NSObject，并没有相应的处理事件的接口。

下面列举一些处理触摸事件的接口
– touchesBegan:withEvent:
– touchesMoved:withEvent:
– touchesEnded:withEvent:
– touchesCancelled:withEvent:

其实还有一些运动和远程控制事件等等，这里就不一一列举了。

参考链接：<br>
http://blog.csdn.net/chun799/article/details/8223612
http://yishuiliunian.gitbooks.io/implementate-tableview-to-understand-ios/content/uikit/1-1-2.html

http://www.cocoachina.com/ios/20150828/13244.html
主要是哪几个来进行区分？？？
https://blog.csdn.net/weiwangchao_/article/details/7771538
http://www.voidcn.com/article/p-sseloeid-pa.html

https://juejin.im/post/5a3891c3f265da4320035c2c
https://juejin.im/post/5b10fbe6f265da6e281bfe45
https://zhuanlan.zhihu.com/p/40683210
https://www.jianshu.com/p/6351116c2d19


ps（总结）:
1）UIView 和CALayer之间的关系
2）UIView继承的UIResponder
3）UIView上面的责任链的实现过程


面试的一个问题的常见答案：
https://wangmeng.gitbooks.io/ios-note/content/interview_1.html










